import { NextRequest, NextResponse } from 'next/server'

export const dynamic = 'force-dynamic'

interface ExportData {
  analytics: any
  exportDate: string
  timeRange: string
  laboratory: string
  generatedBy: string
  summary: {
    totalEquipment: number
    operationalEquipment: number
    complianceScore: number
    aiAccuracy: number
    recommendations: string[]
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { timeRange = '30d', format = 'json' } = body

    // Fetch analytics data
    const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/analytics/metrics?timeRange=${timeRange}`)
    
    if (!response.ok) {
      throw new Error('Failed to fetch analytics data')
    }

    const analyticsData = await response.json()

    // Generate summary
    const summary = {
      totalEquipment: analyticsData.equipmentPerformance.total,
      operationalEquipment: analyticsData.equipmentPerformance.operational,
      complianceScore: analyticsData.complianceData.overall,
      aiAccuracy: analyticsData.aiInsights.accuracy,
      recommendations: generateRecommendations(analyticsData)
    }

    const exportData: ExportData = {
      analytics: analyticsData,
      exportDate: new Date().toISOString(),
      timeRange,
      laboratory: 'Advanced Research Laboratory',
      generatedBy: 'LabGuard-Pro Analytics System',
      summary
    }

    if (format === 'csv') {
      return generateCSVExport(exportData)
    } else if (format === 'pdf') {
      return generatePDFExport(exportData)
    } else {
      return generateJSONExport(exportData)
    }

  } catch (error) {
    console.error('Error generating analytics export:', error)
    return NextResponse.json(
      { error: 'Failed to generate analytics export' },
      { status: 500 }
    )
  }
}

function generateRecommendations(analyticsData: any): string[] {
  const recommendations: string[] = []

  // Equipment health recommendations
  if (analyticsData.equipmentPerformance.avgHealth < 80) {
    recommendations.push('Schedule preventive maintenance for equipment with health scores below 80%')
  }

  if (analyticsData.equipmentPerformance.offline > 0) {
    recommendations.push(`Address ${analyticsData.equipmentPerformance.offline} offline equipment to improve uptime`)
  }

  // Calibration recommendations
  if (analyticsData.calibrationMetrics.overdue > 0) {
    recommendations.push(`Prioritize ${analyticsData.calibrationMetrics.overdue} overdue calibrations to maintain compliance`)
  }

  if (analyticsData.complianceData.overall < 90) {
    recommendations.push('Implement additional quality control measures to improve compliance score')
  }

  // AI insights recommendations
  if (analyticsData.aiInsights.pending > 0) {
    recommendations.push(`Review ${analyticsData.aiInsights.pending} pending AI insights for implementation opportunities`)
  }

  if (analyticsData.aiInsights.accuracy < 95) {
    recommendations.push('Consider retraining AI models to improve prediction accuracy')
  }

  return recommendations
}

function generateJSONExport(data: ExportData) {
  const jsonString = JSON.stringify(data, null, 2)
  const blob = new Blob([jsonString], { type: 'application/json' })
  
  return new NextResponse(blob, {
    headers: {
      'Content-Type': 'application/json',
      'Content-Disposition': `attachment; filename="labguard-analytics-${data.timeRange}-${new Date().toISOString().split('T')[0]}.json"`
    }
  })
}

function generateCSVExport(data: ExportData) {
  const csvRows = [
    ['Metric', 'Value', 'Unit'],
    ['Total Equipment', data.summary.totalEquipment, 'units'],
    ['Operational Equipment', data.summary.operationalEquipment, 'units'],
    ['Compliance Score', data.summary.complianceScore, '%'],
    ['AI Accuracy', data.summary.aiAccuracy, '%'],
    ['Export Date', data.exportDate, ''],
    ['Time Range', data.timeRange, ''],
    ['Laboratory', data.laboratory, ''],
    ['Generated By', data.generatedBy, '']
  ]

  // Add recommendations
  data.summary.recommendations.forEach((rec, index) => {
    csvRows.push([`Recommendation ${index + 1}`, rec, ''])
  })

  const csvContent = csvRows.map(row => row.join(',')).join('\n')
  const blob = new Blob([csvContent], { type: 'text/csv' })

  return new NextResponse(blob, {
    headers: {
      'Content-Type': 'text/csv',
      'Content-Disposition': `attachment; filename="labguard-analytics-${data.timeRange}-${new Date().toISOString().split('T')[0]}.csv"`
    }
  })
}

function generatePDFExport(data: ExportData) {
  // For now, return JSON with PDF format indicator
  // In production, you would use a PDF library like puppeteer or jsPDF
  const pdfData = {
    ...data,
    format: 'pdf',
    note: 'PDF generation would be implemented with a PDF library in production'
  }

  return NextResponse.json(pdfData, {
    headers: {
      'Content-Type': 'application/json',
      'Content-Disposition': `attachment; filename="labguard-analytics-${data.timeRange}-${new Date().toISOString().split('T')[0]}.json"`
    }
  })
} 